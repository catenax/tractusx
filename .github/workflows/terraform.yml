#
# Copyright (c) 2021 T-Systems International GmbH (Catena-X Consortium)
#
# See the AUTHORS file(s) distributed with this work for additional
# information regarding authorship.
#
# See the LICENSE file(s) distributed with this work for
# additional information regarding license terms.
#

#####################################################
# Github Workflow for continuous terraform deployment
#####################################################

name: Terraform Deploy

# Should trigger upon pushs to the terraform related folders

on: 
  push:
    paths:
      - 'infrastructure/terraform/**'
      - '.github/workflows/terraform.yml'

####
# Consists of two jobs, the first determines the environment
# and the second one (doing the real work) only triggers
# if such an environment can be detected (else the workflow is
# green without doing something)
###

jobs:

  ##
  # First job to determine the environment
  ##
  environment:
    name: Determine Target Environment
    runs-on: ubuntu-latest
    outputs:
      workspace: ${{ steps.setvars.outputs.workspace }}

    steps:
      - name: Set variables
        id: setvars
        run: |
          if [[ "${{github.repository}}" == eclipse/tractusx ]]; then
             if [[ "${{github.ref}}" == refs/heads/main ]]; then
                echo "Determined PRODUCTION"
                echo "::set-output name=workspace::prod"
             else
                echo "Unsupported Environment on ECLIPSE. Leaving Workspace empty."
             fi
          else 
            if [[ "${{github.repository}}" == catenax/tractusx ]]; then
              if [[ "${{github.ref}}" == refs/heads/main ]]; then
                echo "Determined INTEGRATION"
                echo "::set-output name=workspace::int"
              elif [[ "${{github.ref}}" = refs/heads/feature/CAX-1-semantics || "${{github.ref}}" = refs/heads/feature/CAX-1-semantics@CXMVP-63-semantic-architecture ]]; then
                  echo "Determined SEMANTICS"
                  echo "::set-output name=workspace::dev042"
              else 
                  echo "Unsupported Branch on CATENAX. Leaving Workspace empty."
              fi
            else
                echo "Unsupported Environment/Repository. Leaving Workspace empty."
            fi
          fi

  ##
  # Second job does the real terraform work
  ##
  terraform:
    name: Terraform Target Environment
    runs-on: ubuntu-latest
    # rely on the first job
    needs: environment
    # rely on successful detection of the workspace, ignore if empty
    if: ${{needs.environment.outputs.workspace}}
    env:
      WORKSPACE: ${{needs.environment.outputs.workspace}}
    steps:

    # This is needed to access blob storage and other resources directly
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # This is needed to install terraform 
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        terraform_version: 1.0.7

    # get the latest sources
    - name: Checkout
      uses: actions/checkout@v2

    # Initialize terraform and move the critical providers (which would hinder an import-before-apply: kubernetes and helm) away for import
    - name: Terraform Init
      working-directory: ./infrastructure/terraform
      run: | 
          terraform init -backend-config="key=catenaxdev.tfstateenv:${{needs.environment.outputs.workspace}}" -backend-config="access_key=${{secrets.TFSTATE_STORAGEACCOUNT_KEY}}" -input=false
          mv provider.tf provider.tf_muted
          
    # Import shared resources into initial state
    # Only called if we are not in the productive environment (which should be responsible for that resource)
    - name: Terraform Import
      if: |
        ${{needs.environment.outputs.workspace}} != "prod"
      continue-on-error: true
      working-directory: ./infrastructure/terraform
      run: |
        terraform import --var-file=environments/${{needs.environment.outputs.workspace}}.tfvars -var azure_subscription_id=${{secrets.AZURE_SUBSCRIPTION_ID}} -var azure_client_id=${{secrets.AZURE_AD_CLIENT_ID}} -var azure_client_secret=${{secrets.AZURE_AD_CLIENT_SECRET}} -var azure_tenant_id=${{secrets.AZURE_AD_TENANT_ID}} -var azure_storage_access_key=${{secrets.TFSTATE_STORAGEACCOUNT_KEY}} -var aks_public_ssh_key=./ssh.pub -input=false azurerm_resource_group.shared_services_rg /subscriptions/caca6914-764f-4187-8c70-67cd966339cf/resourceGroups/shared-services-rg

    # We need a pub key to setup kubernetes if needed
    - name: Download Kubernetes SSH Keys
      working-directory: ./infrastructure/terraform
      run: |
        az storage blob download --name ${{needs.environment.outputs.workspace}}.ssh.pub --container-name sshkeys --account-name catenaxdevtfstate --auth-mode login --file ssh.pub

    # Now move the critical providers (kubernetes, helm) back to the configuration before doing the real planning & application
    - name: Terraform Plan
      working-directory: ./infrastructure/terraform
      run: |
        mv provider.tf_muted provider.tf
        terraform plan --var-file=environments/${{needs.environment.outputs.workspace}}.tfvars -var azure_subscription_id=${{secrets.AZURE_SUBSCRIPTION_ID}} -var azure_client_id=${{secrets.AZURE_AD_CLIENT_ID}} -var azure_client_secret=${{secrets.AZURE_AD_CLIENT_SECRET}} -var azure_tenant_id=${{secrets.AZURE_AD_TENANT_ID}} -var azure_storage_access_key=${{secrets.TFSTATE_STORAGEACCOUNT_KEY}} -var aks_public_ssh_key=./ssh.pub -out .terraform/terraform.plan -input=false

    # For debugging purposes, we log the resulting plan
    - name: Store Terraform Plan
      working-directory: ./infrastructure/terraform
      run: |
        az storage blob upload --name ${{needs.environment.outputs.workspace}}terraform${GITHUB_SHA}.plan --container-name tfplan --account-name catenaxdevtfstate --auth-mode login --file .terraform/terraform.plan --metadata TYPE=TERRAFORM_PLAN

    # The actual terraform apply
    - name: Terraform Auto-Apply
      working-directory: ./infrastructure/terraform
      continue-on-error: true
      run: |
        terraform apply -auto-approve -input=false .terraform/terraform.plan 

    # Login to ACR
    - name: Azure Container Registry Login
      working-directory: ./infrastructure/terraform
      run: |
        az acr login --name catenax${{needs.environment.outputs.workspace}}acr --resource-group catenax-${{needs.environment.outputs.workspace}}-rg 

    # Login to K8
    - name: Kubernetes Login
      uses: azure/aks-set-context@v1
      with:
        creds: '${{ secrets.AZURE_CREDENTIALS }}' # Azure credentials
        resource-group: 'catenax-${{needs.environment.outputs.workspace}}-rg'
        cluster-name: 'catenax-${{needs.environment.outputs.workspace}}-aks-services'
      id: login

    # Deploy cluster issuers 
    - name: Kubernetes Service Plane Client Issuer
      working-directory: ./infrastructure/terraform
      env: 
        ISSUER-VARIANT:
      run: |
        cat cluster-issuer.yaml | envsubst | kubectl apply -f - 

    # Deploy cluster issuers 
    - name: Kubernetes Portal Plane Client Issuer
      working-directory: ./infrastructure/terraform
      env: 
        ISSUER-VARIANT: -portal
      run: |
        cat cluster-issuer.yaml | envsubst | kubectl apply -f - 

    # Allow Azure Service Access to Postgres 
    - name: Azure Postgres Server Firewall Settings
      working-directory: ./infrastructure/terraform
      run: |
        az postgres server firewall-rule create -g catenax-${{needs.environment.outputs.workspace}}-rg -s catenax${{needs.environment.outputs.workspace}}database -n "AllowAllWindowsAzureIps" --start-ip-address "0.0.0.0" --end-ip-address "0.0.0.0"
